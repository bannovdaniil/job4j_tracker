1. Используя различные утилиты для анализа памяти виртуальной машины провести анализ работы программы
job4j_tracker.

2. Профилировать нужно проект с реализацией хранилища в памяти, т.е. MemTracker - добавлять, удалять
и получать данные, при этом отслеживать состояние памяти
  (можете создать отдельные Action с удалением, добавлением).
           for (int i = 0; i < 13000; i++) {
                for (int j = 0; j < i; j++) {
                    Item item = new Item();
                    item.setName(String.valueOf(j));
                    item.setId(j);
                    tracker.add(item);
                }
                try {
                    Thread.sleep(1000);
                } catch (Exception err) {
                    err.printStackTrace();
                }
                System.out.println(tracker.findAll().size());
                for (int j = 0; j < i; j++) {
                    tracker.delete(j);
                }
            }

 постепенно наращиваем нагрузку, добавляем и полностью отчищаем

3. Данные анализа описать в текстовом файле и добавить в репозиторий. В файле нужно указать,
 каким инструментом проведен анализ и что по нему видно.

по утилитам jstat и jmem сложнее делать анализ, т.к. надо собрать сначала лог и после его уже
анализировать, за нас это уже сделано в jconsole.

при использовании jconsole
-объектов создалось меньше примерно на 10000 элементов, по всей видимости jconsole както влияет
 на количество памяти используемое приложением.
график ступенчатый с провалами.
рост. при увеличении количества элементов виден рост,
при провалах видна работа GC, в этоже время нагрузка на CPU возрастает пиково в моменты
сбора мусора. и в моменты расширения внутреннего массива ArrayList.

4. Попробовать добиться состояния выхода за пределы памяти и посмотреть состояние виртуальной машины.
на графике Heap Mem резкое падение до 0 и возврат к последнему значению.
CPU перешёл в 0.